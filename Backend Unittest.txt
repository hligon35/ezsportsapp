"""Backend Unittest"""

from __future__ import annotations

import os
import sys
import time
import unittest
import tempfile

try:
	import msvcrt  # Windows-only; used to simulate an exclusive file lock.
except Exception:  # pragma: no cover
	msvcrt = None


# Make StudyQuest importable when running tests from repo root.
TEST_DIR = os.path.dirname(os.path.abspath(__file__))
DOCS_DIR = os.path.abspath(os.path.join(TEST_DIR, ".."))
if DOCS_DIR not in sys.path:
	sys.path.insert(0, DOCS_DIR)

from StudyQuest import (  # noqa: E402
	Storage,
	Player,
	GoalManager,
	Difficulty,
	Frequency,
)


class _MarkdownTableTestResult(unittest.TextTestResult):
	"""Collect per-test timing and print a markdown table for easy reporting."""

	def __init__(self, *args, **kwargs):
		super().__init__(*args, **kwargs)
		self._started_at: dict[str, float] = {}
		self._rows: list[tuple[str, str, float, str]] = []

	def startTest(self, test):
		self._started_at[test.id()] = time.perf_counter()
		super().startTest(test)

	def _record(self, test, status: str, notes: str = ""):
		started = self._started_at.get(test.id(), None)
		duration = (time.perf_counter() - started) if started is not None else 0.0
		self._rows.append((test.id(), status, duration, notes))

	def addSuccess(self, test):
		super().addSuccess(test)
		self._record(test, "PASS")

	def addSkip(self, test, reason):
		super().addSkip(test, reason)
		self._record(test, "SKIP", str(reason))

	def addFailure(self, test, err):
		super().addFailure(test, err)
		self._record(test, "FAIL")

	def addError(self, test, err):
		super().addError(test, err)
		self._record(test, "ERROR")

	def render_markdown_table(self) -> str:
		# Kept for compatibility if you prefer markdown in a written report.
		lines = ["| Test | Status | Duration (s) | Notes |", "|---|---:|---:|---|"]
		for test_id, status, duration, notes in self._rows:
			safe_notes = (notes or "").replace("\n", " ").replace("|", "/")
			lines.append(f"| {test_id} | {status} | {duration:.3f} | {safe_notes} |")
		return "\n".join(lines)

	def render_grid_table(self, max_notes: int = 80) -> str:
		def short_name(test_id: str) -> str:
			parts = test_id.split(".")
			return parts[-1] if parts else test_id

		rows = []
		for test_id, status, duration, notes in self._rows:
			safe_notes = (notes or "").replace("\n", " ")
			if max_notes and len(safe_notes) > max_notes:
				safe_notes = safe_notes[: max_notes - 1] + "â€¦"
			rows.append([short_name(test_id), status, f"{duration:.3f}", safe_notes])

		headers = ["Test", "Status", "Sec", "Notes"]
		all_rows = [headers] + rows
		widths = [max(len(str(r[i])) for r in all_rows) for i in range(len(headers))]

		def sep(char: str = "-") -> str:
			return "+" + "+".join(char * (w + 2) for w in widths) + "+"

		def fmt(r) -> str:
			cells = [f" {str(r[i]).ljust(widths[i])} " for i in range(len(headers))]
			return "|" + "|".join(cells) + "|"

		out = [sep("-"), fmt(headers), sep("=")]
		for r in rows:
			out.append(fmt(r))
			out.append(sep("-"))
		return "\n".join(out)


class BackendWindowsTests(unittest.TestCase):
	def setUp(self):
		# Use an isolated temp working directory so tests never touch real user data.
		self._tmp = tempfile.TemporaryDirectory(prefix="studyquest_backend_")
		self.addCleanup(self._tmp.cleanup)
		self._old_cwd = os.getcwd()
		os.chdir(self._tmp.name)
		self.addCleanup(lambda: os.chdir(self._old_cwd))

	def _make_loaded_profile(self, num_tasks: int, num_habits: int) -> tuple[Player, GoalManager]:
		player = Player(name="WinTester")
		gm = GoalManager()
		for i in range(num_tasks):
			# Spread due dates so serialization hits both due and no-due paths.
			due = None if (i % 3 == 0) else None
			gm.add_task(f"Task {i}", "Desc", Difficulty.MEDIUM, due)
		for i in range(num_habits):
			freq = Frequency.DAILY if (i % 2 == 0) else Frequency.WEEKLY
			gm.add_habit(f"Habit {i}", "Desc", Difficulty.EASY, freq)
		return player, gm

	def test_save_file_created_in_expected_directory(self):
		"""Save file should be created in the current working directory by default."""
		storage = Storage()  # default path: studyquest_save.txt (relative)
		player, gm = self._make_loaded_profile(2, 2)

		storage.save(player, gm)

		expected = os.path.join(os.getcwd(), "studyquest_save.txt")
		self.assertTrue(os.path.exists(expected), "Expected save file to be created in CWD")
		self.assertGreater(os.path.getsize(expected), 0, "Save file should not be empty")

	def test_load_missing_file_returns_defaults(self):
		"""If save file is missing, backend should start with a default Player/GoalManager."""
		storage = Storage("studyquest_save.txt")
		self.assertFalse(os.path.exists(storage.path))
		player, gm = storage.load()
		self.assertEqual(player.name, "Student")
		self.assertEqual(player.level, 1)
		self.assertEqual(len(gm.goals), 0)

	def test_corrupted_save_file_raises_value_error(self):
		"""Corrupted save should raise so the GUI can warn+start fresh (no silent corruption)."""
		storage = Storage("studyquest_save.txt")
		with open(storage.path, "w", encoding="utf-8") as f:
			f.write("NOT_A_PLAYER|oops\n")
			f.write("GOAL|TASK|1|Title|Desc|Easy|||\n")
		with self.assertRaises(ValueError):
			storage.load()

	def test_manual_edit_unknown_goal_type_is_rejected(self):
		"""Manually edited goal lines must not crash later; they should be rejected on load."""
		storage = Storage("studyquest_save.txt")
		with open(storage.path, "w", encoding="utf-8") as f:
			f.write("PLAYER|Student|1|0|100\n")
			f.write("GOAL|ALIEN|1|X|Y|Easy\n")
		with self.assertRaises(ValueError):
			storage.load()

	@unittest.skipUnless(os.name == "nt" and msvcrt is not None, "Windows-only file locking test")
	def test_save_fails_cleanly_when_destination_file_is_locked(self):
		"""If the save file is locked, os.replace should fail and we should not overwrite it."""

		storage = Storage("studyquest_save.txt")
		player, gm = self._make_loaded_profile(10, 10)
		storage.save(player, gm)

		# Snapshot file contents BEFORE locking. On Windows, an exclusive lock may block reads.
		before = open(storage.path, "rb").read()

		# Lock the destination file. On Windows this commonly blocks rename/replace.
		# Note: locking semantics can vary; this is a best-effort OS test.
		with open(storage.path, "r+", encoding="utf-8") as locked:
			try:
				msvcrt.locking(locked.fileno(), msvcrt.LK_NBLCK, 1)
			except OSError:
				self.skipTest("Could not acquire file lock on this system")

			# Try to save again; expected: PermissionError (or OSError).
			with self.assertRaises((PermissionError, OSError)):
				storage.save(player, gm)

			# Cleanup lock before validating file contents.
			try:
				msvcrt.locking(locked.fileno(), msvcrt.LK_UNLCK, 1)
			except OSError:
				pass

		after = open(storage.path, "rb").read()
		self.assertEqual(before, after, "Locked destination should not be partially overwritten")

		# If os.replace failed, a .tmp may remain; ensure it doesn't break subsequent saves.
		tmp_path = storage.path + ".tmp"
		if os.path.exists(tmp_path):
			os.remove(tmp_path)
		storage.save(player, gm)
		self.assertTrue(os.path.exists(storage.path))

	def test_save_and_load_performance_under_load_smoke(self):
		"""Performance smoke test: save/load should complete reasonably with many goals."""
		storage = Storage("studyquest_save.txt")
		player, gm = self._make_loaded_profile(num_tasks=1500, num_habits=1500)

		t0 = time.perf_counter()
		storage.save(player, gm)
		t1 = time.perf_counter()
		loaded_player, loaded_gm = storage.load()
		t2 = time.perf_counter()

		save_s = t1 - t0
		load_s = t2 - t1

		# Keep thresholds generous to avoid flaky CI/lab machine variance.
		self.assertLess(save_s, 5.0, f"Save too slow under load on Windows: {save_s:.2f}s")
		self.assertLess(load_s, 5.0, f"Load too slow under load on Windows: {load_s:.2f}s")
		self.assertEqual(loaded_player.name, "WinTester")
		self.assertEqual(len(loaded_gm.goals), len(gm.goals))

		# Output for parity comparison with macOS tester.
		print(f"[Windows Backend Perf] goals={len(gm.goals)} save={save_s:.3f}s load={load_s:.3f}s")


if __name__ == "__main__":
	# Running directly prints a markdown table you can paste into a test report.
	suite = unittest.defaultTestLoader.loadTestsFromModule(sys.modules[__name__])
	runner = unittest.TextTestRunner(verbosity=2, resultclass=_MarkdownTableTestResult)
	result = runner.run(suite)
	print("\n## Backend Test Results (Windows)\n")
	print(result.render_grid_table())
	raise SystemExit(0 if result.wasSuccessful() else 1)

